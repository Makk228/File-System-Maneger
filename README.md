
# File System Manager

> Консольное **REPL-приложение** на **C# (.NET)** для взаимодействия и управления файловой системой.  
> Проект служит учебной работой для проверки владения принципами **SOLID**, шаблонами проектирования и архитектурным подходом **Hexagonal (Ports & Adapters)**.  
> Логика приложения полностью отделена от консольного интерфейса и от конкретной реализации файловой системы.

---

## Содержание

- [Описание проекта](#описание-проекта)
- [Ключевые возможности](#ключевые-возможности)
- [Архитектура](#архитектура-high-level-hexagonal-ports--adapters)
- [Поддерживаемые команды (синтаксис и примеры)](#поддерживаемые-команды--синтаксис-и-примеры)
- [Примеры сессий](#примеры-сессий)
- [Технические детали реализации](#технические-детали-реализации)
- [Обработка ошибок и коллизий](#обработка-ошибок-и-коллизий)
- [Сборка и запуск](#сборка-и-запуск)
- [Тестирование](#тестирование-рекомендации)
- [Структура проекта (рекомендуемая)](#структура-проекта-рекомендуемая)
- [CI (пример GitHub Actions)](#ci-пример-github-actions)
- [Расширение и вклад](#расширяемость-как-добавить-новые-возможности)
- [Лицензия](#рекомендации-по-стилю-кода-и-вкладу)

---

## Описание проекта

**File System Manager** — инструмент для:

- навигации по файловой системе (unix-пути, поддержка `.` и `..`),
- просмотра содержимого каталогов в виде дерева с настраиваемой глубиной,
- чтения содержимого файлов,
- перемещения, копирования, удаления и переименования файлов,
- подключения к точке монтирования (path of mount) и работы внутри локального пути,
- работы через расширяемый парсер консольных команд (флаги и параметры),
- демонстрации принципов SOLID и Hexagonal Architecture.

**Платформа:** C#, .NET 6+ (рекомендуется).

---

## Ключевые возможности

- Поддержка абсолютных и относительных unix-путей.
- REPL-интерфейс (после выполнения команды приложение ждёт следующую).
- Парсер команд отделён от логики и расширяем (OCP).
- Логика работы не привязана к консоли и не зависит от реализации ФС.
- Реализован локальный адаптер ФС (LocalFileSystemAdapter); предусмотрен InMemory адаптер для тестов.
- Ленивое перечисление директорий и потоковое чтение файлов (низкое потребление памяти).
- Параметры отображения дерева (символы, отступы, обозначение файлов/папок) программно настраиваемы.

---

## Архитектура (High-level) Hexagonal (Ports & Adapters)

- Presentation → Core.Application → Core.Domain
- Core.Infrastructure реализует порты и подключается через DI

### Основные слои

- **Core.Domain:** сущности и порты (интерфейсы): `IFileSystem`, `IDirectoryEnumerator`, `IFileReader`, `IFileWriter`, `PathModel`, доменные исключения.
- **Core.Application:** Use Cases / Interactors: `Connect`, `Disconnect`, `ListTree`, `ShowFile`, `Move`, `Copy`, `Delete`, `Rename`.
- **Core.Infrastructure:** `LocalFileSystemAdapter` (System.IO), `InMemoryFileSystemAdapter` (для тестов), `Logger`.
- **Presentation:** `CommandParser`, `CommandDispatcher`, `ConsoleAdapter` (`IConsole`) — REPL.

### Основные принципы и паттерны

- Command pattern (`ICommand` / `ICommandHandler`)
- Adapter / Strategy (разные реализации `IFileSystem`)
- Factory (создание сессий/адаптеров)
- DI (внедрение зависимостей)
- Lazy enumeration (`IEnumerable` / `IAsyncEnumerable`)
- Модульный парсер флагов (`IFlagHandler`) — расширяемость по OCP

---

## Поддерживаемые команды — синтаксис и примеры

### Общие правила

- Пути — unix-стиля (`/`), поддерживаются `.` и `..`.
- Абсолютный путь начинается с `/` и трактуется относительно пути подключения (mount point).  
  Пример: если подключение выполнено в `/mnt/data`, то `/docs` означает `/mnt/data/docs`.
- Относительный путь — относительно текущего локального пути.
- Локальный путь не может выйти за пределы пути подключения.
- Пока не выполнена команда `connect`, доступны только команды `connect`.

---

### 1) `connect [Address] [-m Mode]`

**Описание:** подключает программу к ФС по абсолютному адресу; устанавливает локальный путь равным корню подключения.

**Параметры:**
- `Address` — абсолютный путь (обязательно).
- `-m Mode` — режим файловой системы (по умолчанию `local`). Сейчас реализован `local`.

**Пример:**
```bash
connect /home/student/projects -m local
````

---

### 2) `disconnect`

**Описание:** отключает текущее подключение. После этого доступны только `connect`.

**Пример:**

```bash
disconnect
```

---

### 3) `tree goto [Path]`

**Описание:** смена локального пути. Path может быть относительным или абсолютным. Результат должен находиться внутри пути подключения.

**Примеры:**

```bash
tree goto ../other-project
tree goto /docs/specs
```

---

### 4) `tree list {-d Depth}`

**Описание:** печатает дерево каталога относительно текущего локального пути.

**Параметры:**

- `-d Depth` — глубина обхода (по умолчанию 1).
    

**Пример:**

```bash
tree list -d 2
```

Параметры визуализации дерева (конфигурируемые): символы для папки/файла, символы отступов, маркеры ветвей.

---

### 5) `file show [Path] {-m Mode}`

**Описание:** вывод содержимого файла.

**Параметры:**

- `Path` — абсолютный или относительный путь.
    
- `-m Mode` — режим вывода (по умолчанию `console`). (Можно расширить: raw, hex, pager).
    

**Примеры:**

```bash
file show ./notes.txt
file show /docs/readme.md -m console
```

---

### 6) `file move [SourcePath] [DestinationPath]`

**Описание:** перемещает файл.

Правила разрешения пути: абсолютный путь — относительно пути подключения; относительный — относительно локального пути.

**Пример:**

```bash
file move src/old.txt ../archive/
```

---

### 7) `file copy [SourcePath] [DestinationPath]`

**Описание:** копирует файл в указанную директорию.

**Пример:**

```bash
file copy ./report.pdf /backup/reports/
```

---

### 8) `file delete [Path]`

**Описание:** удаляет указанный файл.

**Пример:**

```bash
file delete ./temp.txt
```

---

### 9) `file rename [Path] [Name]`

**Описание:** переименовывает файл без перемещения. Name не должен содержать путь (`/`).

**Пример:**

```bash
file rename ./notes.txt meeting-notes.txt
```

---

## Примеры сессий

### Подключение и просмотр

```text
> connect /home/student/projects -m local
Connected to /home/student/projects
> tree list -d 1
/projects
├─ src
└─ README.md
```

### Переход и показ файла

```text
> tree goto src
Current: /projects/src
> file show Program.cs
// содержимое файла Program.cs
```

### Перемещение с коллизией

```text
> file move notes.txt ../archive/
Error: destination already contains a file named notes.txt — use --overwrite to replace.
```

---

## Технические детали реализации

### Ленивость и потребление памяти

- Перечисление директорий реализовано лениво с использованием итераторов (yield / IAsyncEnumerable) — при `tree list -d N` запрашиваются только необходимые узлы.
    
- Чтение и копирование файлов выполняется потоками (Stream), данные читаются блоками; большие файлы не загружаются целиком в память.
    
- В памяти не хранится полный срез ФС одновременно; создаются только узлы, нужные для текущей операции.
    

### Парсер команд и OCP

- Парсер формирует объекты-команды (ICommand) с аргументами и набором флагов.
    
- Флаги обрабатываются независимыми обработчиками (IFlagHandler), что позволяет добавлять новые флаги без изменения центра парсинга.
    

---

## Обработка ошибок и коллизий

- `NotConnectedException` — попытка выполнить команду без подключения (кроме `connect`).
    
- `NotFoundException` — файл или каталог не найден.
    
- `CollisionException` — при коллизии имён (move/copy); в текущей реализации операция отклоняется, можно добавить флаг `--overwrite` или `--suffix`.
    
- `ValidationException` — неверный набор аргументов (например имя для rename содержит `/`).
    
- Все ошибки возвращаются пользователю в читаемом формате; приложение не аварийно завершает работу.
    

---

## Тестирование (рекомендации)

**Обязательные тесты:**

- ParserTests: корректная трансформация строк в команды и флаги.
    
- UseCaseTests: бизнес-логика Move/Copy/Delete/Rename/Show/List с InMemoryFileSystemAdapter.
    
- BoundaryTests: локальный путь не выходит за root подключения.
    
- CollisionTests: корректная реакция при коллизиях.
    
- IntegrationTests: end-to-end сценарии с временными директориями.
    

---

## Сборка и запуск

```bash
dotnet restore
dotnet build
dotnet test
dotnet run --project src/Presentation
```

---

## Расширяемость (как добавить новые возможности)

- Новый адаптер ФС: реализовать IFileSystem/IDirectoryEnumerator/IFileReader/IFileWriter и зарегистрировать в DI.
    
- Новые режимы вывода (file show -m): добавить стратегию IFileOutputMode и зарегистрировать.
    
- Новые флаги: реализовать IFlagHandler и зарегистрировать в CommandParser (не менять реализацию парсера).
    
- Перезапись/суффикс при коллизии: добавить флаги `--overwrite`, `--suffix` и соответствующую логику в Use Case.
    

---

## Рекомендации по стилю кода и вкладу

- Следовать SOLID-принципам.
    
- Писать unit-тесты для каждого use-case.
    
- Избегать глобальных статических состояний.
    
- Писать XML-комментарии для публичных API.
    
- Маленькие, атомарные коммиты; PR с описанием и тестами.
